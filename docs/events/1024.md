# 致敬1024,《手搓》轻量级EventBus

## 一、.NET事件总线一般使用MediatR
>笔者手搓件事件总线和MediatR对比一下

### 二、事件处理的基本概念
### 1. 事件
>* 表示已经发生的事情,需要通知其他模块进行处理

### 2. 事件发布器
>* 负责发布事件的对象

### 3. 事件处理器
>* 实际接收到通知并处理事件的对象

### 4. 事件分发器
>* 负责将事件通知给对应的事件处理器

### 5. 事件总线
>* 用于协调各个组件

## 三、 先看一下MediatR的Case
>* 用INotification来表示事件
>* 用INotificationHandler<T>来表示事件处理器
>* IMediator多重身份,既是事件发布器,又是事件总线
>* INotificationPublisher是事件分发器

### 1. 测试代码
>* 使用GenericNotification表示事件
>* CreateNotification()表示主业务,使用异步处理
>* A和B两个处理器表示其他模块业务订阅该事件,并进行异步处理
>* 以上模拟一个简单事件使用的过程

```csharp
record GenericNotification(string Name) : INotification;
static async Task<GenericNotification> CreateNotification()
{
    var notification = new GenericNotification("GenericNotification");
    await Task.Delay(1000);
    return await Task.FromResult(notification);
}
class GenericANotificationHandler : INotificationHandler<GenericNotification>
{
    public async Task Handle(GenericNotification notification, CancellationToken cancellationToken)
    {
        Console.WriteLine($"GenericANotificationHandler {notification.Name},ThreadId:{Environment.CurrentManagedThreadId}");
        await Task.Delay(1000, cancellationToken);
    }
}
class GenericBNotificationHandler : INotificationHandler<GenericNotification>
{
    public async Task Handle(GenericNotification notification, CancellationToken cancellationToken)
    {
        Console.WriteLine($"GenericBNotificationHandler {notification.Name},ThreadId:{Environment.CurrentManagedThreadId}");
        await Task.Delay(2000, cancellationToken);
    }
}
```

### 2. 运行一下
>* 使用MediatR的Publish方法异步发布事件

```csharp
var mediator = serviceCollection.GetRequiredService<IMediator>();
var sw = Stopwatch.StartNew();
var notification = await CreateNotification();
Console.WriteLine($"Publish {notification.Name},ThreadId:{Environment.CurrentManagedThreadId}");
await mediator.Publish(notification);
Console.WriteLine($"总耗时：{sw.ElapsedMilliseconds}ms");
// Publish GenericNotification,ThreadId:11
// GenericANotificationHandler GenericNotification,ThreadId:11
// GenericBNotificationHandler GenericNotification,ThreadId:11
// 总耗时：4015ms
```

### 3. 分析一下结果
>* 首先业务需求是很好的实现了
>* 虽然全都用了异步,却感觉是同步执行
>* 连实际线程ID都是一样一样的
>* 耗时更是惨不忍睹,如果发布一个事件会拖累主业务,那谁还敢用事件呢?
>* 有人可能会说去掉Publish的await就行了,不await你能保证处理器都全部能执行吗?
>* 为此笔者手搓一个事件总线,来解决这个问题

## 四、手搓一个事件总线
### 1. 测试代码
>* 还是使用GenericNotification表示事件
>* CreateNotification()表示主业务,使用异步处理
>* A和B两个处理器表示其他模块业务订阅该事件,并进行异步处理
>* 这次用的是ITaskEventHandler<T>接口,表示事件异步处理器

```csharp
record GenericNotification(string Name) : INotification;
static async Task<GenericNotification> CreateNotification()
{
    var notification = new GenericNotification("GenericNotification");
    await Task.Delay(1000);
    return await Task.FromResult(notification);
}
internal class AEventHandler : ITaskEventHandler<GenericNotification>
{
    public async Task TaskHandle(GenericNotification @event, CancellationToken cancellationToken)
    {
        Console.WriteLine($"AEventHandler {@event.Name},ThreadId:{Environment.CurrentManagedThreadId}");
        await Task.Delay(1000, cancellationToken);
    }
}
internal class BEventHandler : ITaskEventHandler<GenericNotification>
{
    public async Task TaskHandle(GenericNotification @event, CancellationToken cancellationToken)
    {
        Console.WriteLine($"BEventHandler {@event.Name},ThreadId:{Environment.CurrentManagedThreadId}");
        await Task.Delay(1000, cancellationToken);
    }
}
```

### 2. 运行一下
>* 使用IEventBus的Publish同步方法发布事件

```csharp
var eventBus = serviceCollection.GetRequiredService<IEventBus>();
var sw = Stopwatch.StartNew();
var notification = await CreateNotification();
Console.WriteLine($"Publish {notification.Name},ThreadId:{Environment.CurrentManagedThreadId}");
eventBus.Publish(notification);
Console.WriteLine($"总耗时：{sw.ElapsedMilliseconds}ms");
// Publish GenericNotification,ThreadId:11
// 总耗时：1008ms
// AEventHandler GenericNotification,ThreadId:10
// BEventHandler GenericNotification,ThreadId:11
```

### 3. 分析一下结果
>* 业务需求同样是很好的实现了
>* IMediator换成了IEventBus
>* 但耗时只有1秒钟,也就是说没有拖慢主业务
>* 前面显示事件处理的日志都在主业务之后,更说明是异步处理的

## 五. 揭秘手搓事件总线
### 1. IEventBus的Publish是同步方法
>* 但实际内部是异步处理的
>* 是调用自定义线程池来执行的
>* 是不是有点拗口,同步方法实际是异步处理
>* MediatR的Publish异步方法,实际要同步处理

```csharp
public interface IEventBus
{
    void Publish<TEvent>(TEvent @event);
}
```

### 2. EventBus配置代码
>* 使用ScanEventHandler扫描并注册事件处理器
>* 通过EventBusOptions配置EventBus内置线程池的并发
>* 通过内置线程池给事件处理单独提供了线程资源和并发控制
>* 既可以保障事件处理,还可以避免事件处理耗完整个程序CPU资源
>* 最后注册EventBus

```csharp
var serviceCollection = new ServiceCollection()
    .ScanEventHandler(ServiceLifetime.Scoped, Assembly.GetExecutingAssembly())
    .AddSingleton(new EventBusOptions { ConcurrencyLevel = 10 })
    .AddEventBus<EventBus>();
```

### 3. 支持同步事件处理
>* IEventHandler是同步事件处理接口
>* 一般最好涉及IO操作才用异步
>* 只是简单操作用用同步性能更好
>* 如果是CPU密集计算最好把那部分单独调用自定义线程来排队执行
>* 避免拖垮整个程序

```csharp
internal class CEventHandler : IEventHandler<GenericNotification>
{
    public void Handle(GenericNotification @event)
    {
        Console.WriteLine($"CEventHandler {@event.Name},ThreadId:{Environment.CurrentManagedThreadId}");
    }
}
```

### 4. 同步执行结果
```csharp
Publish GenericNotification,ThreadId:11
总耗时：1009ms
AEventHandler GenericNotification,ThreadId:10
BEventHandler GenericNotification,ThreadId:11
CEventHandler GenericNotification,ThreadId:10
```

### 5. 手搓事件总线的边缘
>* 支持net4.5+和netstandard1.1+,也就是说非.net core也支持
>* 但是ServiceCollection支持的没有这么全
>* 因此提供了Hand.EventDictionaryProvider不依赖IOC环境

#### 5.1 使用代码
>* EventBus也支持EventHandlerDictionaryProvider
>* 只是注册事件处理器没有IOC方便,但至少能用

```csharp
EventHandlerDictionaryProvider provider = new();
var handler = new Handler();
provider.AddHandler(handler);
EventBus bus = new(provider, new EventBusOptions { ConcurrencyLevel = 1 });
```


### 6. 集成事件的探讨
>* 集成事件就是分布式事件,跨进程的事件
>* 这种事件肯定要借助消息队列中间件
>* 做一个事件转发器(继承事件处理接口)就可以了,手写并不复杂
>* 如何封装事件转发器笔者还没考虑清楚
>* 下次考虑清楚了再发一篇文章

### 7. 总结
>* IEventBus作为事件总线和事件发布者
>* IEventHandler和ITaskEventHandler作为
>* IEventHandlerProvider用于查找事件处理器,支持非IOC环境
>* EventDispatcher是事件发布者包含在EventBus内部
>* 用于调用内置线程池发布事件和跟踪异步事件执行完成()

## 六. 手搓事件总线非常轻量级
### 1. MediatR已经非常轻量级了
>* MediatR.Contracts.dll是7K
>* MediatR.dll是76K

### 2. 手搓事件总线更轻量级
>* 本示例用到手搓的6个类库,共61K
>* Hand.EventBuses.dll是9K
>* Hand.EventServiceProvider.dll是6K
>* Hand.Core.dll是14K
>* Hand.Tasks.dll是13K
>* Hand.Reflection.dll是11K
>* Hand.Job.dll是9K
>* 其中只有Hand.EventBuses.dll和Hand.EventServiceProvider.dll是专用事件总线的,共15K
>* 其他4个类库是《手搓》系列的通用类库,可以复用与其他场景

## 七、插一个异步的题外话
### 1. 模拟一个异步业务场景
>* 有3个异步逻辑的结果聚合
>* 每个异步逻辑都需要1秒钟

```csharp
public static async Task<int> Sum(params int[] input)
{
    await Task.Delay(1000);
    return input.Sum();
}
public static async Task<int> One()
{
    await Task.Delay(1000);
    return 1;
}
public static async Task<int> Two()
{
    await Task.Delay(1000);
    return 2;
}
public static async Task<int> Tree()
{
    await Task.Delay(1000);
    return 3;
}
```

### 2. 先给一个错误的示范
```csharp
var sw = Stopwatch.StartNew();
var one = await One();
var two = await Two();
var tree = await Tree();
var sum = await Sum(one, two, tree);
Assert.Equal(6, sum);
sw.Stop();
_output.WriteLine($"Async Total Time: {sw.ElapsedMilliseconds} ms");
// Async Total Time: 4020 ms
```

>* 以上代码看着很漂亮,但是实际执行时间是4秒
>* 因为每个异步逻辑都是顺序执行的
>* 这显然不是我们想要的结果

### 3. 可以这么优化
```csharp
var sw = Stopwatch.StartNew();
var oneTask = One();
var twoTask = Two();
var treeTask = Tree();
var list = await Task.WhenAll(oneTask, twoTask, treeTask);
var sum = await Sum(list);
Assert.Equal(6, sum);
sw.Stop();
_output.WriteLine($"WhenAll Async Total Time: {sw.ElapsedMilliseconds} ms");
// WhenAll Async Total Time: 2016 ms
```

>* 以上代码耗时2秒
>* 因为我们将异步逻辑并行执行了
>* 很多时候不要看到Task就加await
>* 更别觉得有Task有await,就是异步了

### 4. 不用WhenAll可以这么写
```csharp
var sw = Stopwatch.StartNew();
var oneTask = One();
var twoTask = Two();
var treeTask = Tree();
var one = await oneTask;
var two = await twoTask;
var tree = await treeTask;
var sum = await Sum(one, two, tree);
Assert.Equal(6, sum);
sw.Stop();
_output.WriteLine($"Parallel Async Total Time: {sw.ElapsedMilliseconds} ms");
// Parallel Async Total Time: 2017 ms
```

>* 为什么要说这个题外话
>* 因为我看到太多项目都是这样子,甚至在循环里面逐个await
>* 虽然看上去是一手漂亮的代码,但是执行效率却很低
>* 希望说破这个事情,能帮到一部分人

