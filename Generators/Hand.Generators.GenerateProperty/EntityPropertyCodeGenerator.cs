using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;

namespace Hand.Generators.GenerateProperty;

/// <summary>
/// 生成实体属性
/// </summary>
[Generator(LanguageNames.CSharp)]
public class EntityPropertyCodeGenerator : IIncrementalGenerator
{
    /// <summary>
    /// 生成一个类
    /// </summary>
    /// <param name="context"></param>
    /// <param name="namedTypeSymbol"></param>
    /// <param name="classOrStruct"></param>
    /// <param name="sourceType"></param>
    private void GenerateType(List<string> modifiers, SourceProductionContext context, TypeDeclarationSyntax tds, INamedTypeSymbol namedTypeSymbol)
    {
        var (sourceType, sourceIsValue) = GetSourceType(namedTypeSymbol);
        if (string.IsNullOrEmpty(sourceType))
            return;
        var (classOrStruct, isValueType, isRecord) = GetClassOrStructKeyword(tds);
        string ns = namedTypeSymbol.ContainingNamespace.ToString();
        string className = namedTypeSymbol.Name;
        MemberBuilder builder = new(new("// <auto-generated/>\r\n"));
        builder.AddUsing("System");
        builder.AddRange(tds.Members);

        builder.GenerateUsing();
        #region GenerateCode
        builder.GenerateNamespace(ns);
        using (GenerateBlock.Create(builder))
        {
            //var modifier = string.Join(" ", modifiers);
            builder.GenerateModifiers(modifiers);
            if (isRecord)
                builder.AppendLine($"{classOrStruct} {className}({sourceType} Value)");
            else
                builder.AppendLine($"{classOrStruct} {className} : IEquatable<{className}>");
            
            using (GenerateBlock.Create(builder))
            {
                if (!isRecord)
                {                    
                    GenerateConstructor(builder, className, sourceType);
                    var isReadOnly = modifiers.Contains("readonly");
                    GenerateValueProperty(builder, sourceType, isReadOnly);
                }
                var memberName = isRecord ? "Value" : "_value";
                GenerateToString(builder, sourceType, sourceIsValue, memberName);
                var equals = false;
                if (!isRecord)
                    equals = GenerateEquals(builder, className, isValueType, sourceIsValue, memberName);
                GenerateGetHashCode(builder, sourceIsValue, memberName);
                if (equals && !isRecord)
                    GenerateOperator(builder, className, isValueType);
            }
        }
        #endregion
        context.AddSource($"{ns}.{className}.g.cs", builder.ToString());
    }
    /// <summary>
    /// 生成构造函数
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="className"></param>
    /// <param name="sourceType"></param>
    /// <returns></returns>
    private bool GenerateConstructor(MemberBuilder builder, string className, string sourceType)
    {
        if (builder.CheckConstructor(sourceType))
            return false;
        builder.BuildConstructor(className, "public");
        builder.AppendLineNoIndent($"({sourceType} value)");
        using (GenerateBlock.Create(builder))
        {
            builder.AppendLine("_value = value;");
        }
        return true;
    }
    /// <summary>
    /// 生成Value属性
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="sourceType"></param>
    /// <param name="isReadOnly"></param>
    /// <returns></returns>
    private bool GenerateValueProperty(MemberBuilder builder, string sourceType, bool isReadOnly)
    {
        if (isReadOnly)
            builder.TryBuildField("_value", sourceType, "private", "readonly");
        else
            builder.TryBuildField("_value", sourceType, "private");
        return builder.TryBuildPropertyByField("Value", sourceType, false, "_value", "public");
    }
    /// <summary>
    /// 生成ToString
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="sourceType"></param>
    /// <param name="isValueType"></param>
    /// <param name="memberName"></param>
    /// <returns></returns>
    private bool GenerateToString(MemberBuilder builder, string sourceType, bool isValueType, string memberName = "_value")
    {
        if (!builder.TryBuildMethod("ToString", "string", "public", "override"))
            return false;
        builder.AppendLineNoIndent("()");
        using (GenerateBlock.Create(builder))
        {
            if (sourceType.Equals("string"))
                builder.AppendLine($"return {memberName};");
            else if (isValueType)
                builder.AppendLine($"return {memberName}.ToString();");
            else
                builder.AppendLine($"return {memberName}?.ToString();");
        }
        return true;
    }
    /// <summary>
    /// 生成Equals
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="className"></param>
    /// <param name="isValueType"></param>
    /// <param name="sourceIsValue"></param>
    /// <param name="memberName"></param>
    /// <returns></returns>
    private static bool GenerateEquals(MemberBuilder builder, string className, bool isValueType, bool sourceIsValue, string memberName = "_value")
    {
        var method = "Equals";
        if (builder.MethodContains(method))
            return false;
        IEnumerable<string> modifiers = ["public"];
        if (sourceIsValue)
        {
            //struct对virtual无效
            builder.BuildMethod("Equals", "bool", modifiers);
            //struct定义Equals不加可空
            builder.AppendLineNoIndent($"({className} other)");
        }
        else
        {
            if (sourceIsValue)
                modifiers = modifiers.Append("virtual");
            builder.AppendLine("#nullable enable");
            builder.BuildMethod("Equals", "bool", modifiers);
            builder.AppendLineNoIndent($"({className}? other)");
            builder.AppendLine("#nullable disable");
        }

        using (GenerateBlock.Create(builder))
        {
            if (!isValueType)
            {
                builder.AppendLine("if (other is null) return false;");
                builder.AppendLine("if (ReferenceEquals(this, other)) return true;");
            }
            if (sourceIsValue)
            {
                builder.AppendLine($"return {memberName}.Equals(other.{memberName});");
            }
            else
            {
                builder.AppendLine($"var otherValue = other.{memberName};");
                builder.AppendLine($"if ({memberName} is null)");
                using (GenerateBlock.Create(builder))
                {
                    builder.AppendLine("if (otherValue is null) return true;");
                    builder.AppendLine("return false;");
                }
                builder.AppendLine($"return {memberName}.Equals(otherValue);");
            }
        }
        GenerateOverrideEquals(builder, className);
        return true;
    }
    /// <summary>
    /// 生成Equals重载
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="className"></param>
    private static void GenerateOverrideEquals(MemberBuilder builder, string className)
    {
        builder.BuildMethod("Equals", "bool", "public", "override");
        builder.AppendLineNoIndent($"(object obj)");
        using (GenerateBlock.Create(builder))
        {
            builder.AppendLine($"return obj is {className} other && Equals(other);");
        }
    }
    /// <summary>
    /// 生成运算符重载
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="className"></param>
    /// <param name="isValueType"></param>
    private static void GenerateOperator(MemberBuilder builder, string className, bool isValueType)
    {
        builder.AppendLine($"public static bool operator ==({className} a, {className} b)");
        using (GenerateBlock.Create(builder))
        {
            if (!isValueType)
                builder.AppendLine("if (a is null) return b is null;");
            builder.AppendLine("return a.Equals(b);");
        }
        builder.AppendLine($"public static bool operator !=({className} a, {className} b)");
        using (GenerateBlock.Create(builder))
        {
            builder.AppendLine("return !(a == b);");
        }
    }
    /// <summary>
    /// 生成GetHashCode
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="isValueType"></param>
    /// <param name="memberName"></param>
    /// <returns></returns>
    private bool GenerateGetHashCode(MemberBuilder builder, bool isValueType, string memberName = "_value")
    {
        if (!builder.TryBuildMethod("GetHashCode", "int", "public", "override"))
            return false;
        builder.AppendLineNoIndent("()");
        using (GenerateBlock.Create(builder))
        {
            if (isValueType)
                builder.AppendLine($"return {memberName}.GetHashCode();");
            else
                builder.AppendLine($"return {memberName} is null ? 0 : {memberName}.GetHashCode();");
        }
        return true;
    }
    #region Initialize
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //找到对什么文件感兴趣
        var provider = context.SyntaxProvider
             .CreateSyntaxProvider(Filters, Transform);
        //Debugger.Launch();
        //注册输出逻辑
        context.RegisterSourceOutput(provider, Execute);
    }
    /// <summary>
    /// 执行
    /// </summary>
    /// <param name="productionContext"></param>
    /// <param name="syntaxContext"></param>
    void Execute(SourceProductionContext productionContext, GeneratorSyntaxContext syntaxContext)
    {
        if (syntaxContext.Node is not TypeDeclarationSyntax node)
            return;
        var modifiers = node.Modifiers.Select(m => m.ValueText).ToList();
        // 只支持部分类
        if (modifiers.Contains("partial"))
        {
            var namedTypeSymbol = syntaxContext.SemanticModel.GetDeclaredSymbol(node);
            if (namedTypeSymbol is null)
                return;
            GenerateType(modifiers, productionContext, node, namedTypeSymbol);
        }
    }
    /// <summary>
    /// 过滤
    /// </summary>
    /// <param name="syntaxNode"></param>
    /// <param name="cancellation"></param>
    /// <returns></returns>
    static bool Filters(SyntaxNode syntaxNode, CancellationToken cancellation)
    {
        if (cancellation.IsCancellationRequested)
            return false;
        return syntaxNode.Kind() is SyntaxKind.ClassDeclaration
            or SyntaxKind.StructDeclaration
            or SyntaxKind.RecordDeclaration
            or SyntaxKind.RecordStructDeclaration;
    }
    /// <summary>
    /// 转换
    /// </summary>
    /// <param name="context"></param>
    /// <param name="cancellation"></param>
    /// <returns></returns>
    static GeneratorSyntaxContext Transform(GeneratorSyntaxContext context, CancellationToken cancellation)
        => context;
    #endregion
    #region 工具方法
    /// <summary>
    /// ClassOrStruct
    /// </summary>
    /// <param name="node"></param>
    /// <returns></returns>
    static (string classOrStruct, bool isValueType, bool isRecord) GetClassOrStructKeyword(TypeDeclarationSyntax node)
    {
        if (node is ClassDeclarationSyntax)
        {
            return ("class", false, false);
        }
        else if (node is StructDeclarationSyntax)
        {
            //Debugger.Launch();
            return ("struct", true, false);
        }
        else if (node is RecordDeclarationSyntax record)
        {
            if (record.ClassOrStructKeyword.ValueText is "struct")
                return ("record struct", true, true);
            return ("record", false, true);
        }
        return ("class", false, false);
    }
    /// <summary>
    /// 获取源类型
    /// </summary>
    /// <param name="namedTypeSymbol"></param>
    /// <returns></returns>
    /// <exception cref="System.Exception"></exception>
    static (string typeName, bool isValueType) GetSourceType(INamedTypeSymbol namedTypeSymbol)
    {
        if (namedTypeSymbol is null)
            throw new System.Exception("namedTypeSymbol is null");
        var id = namedTypeSymbol.AllInterfaces
            .FirstOrDefault(item => item.Name == "IEntityId");
        if (id is not null)
            return ("long", true);
        var property = namedTypeSymbol.AllInterfaces
            .FirstOrDefault(item => item.Name == "IEntityProperty");
        if (property == null || property.TypeArguments.Length != 1)
            throw new System.Exception("property not found");
        var argument = property.TypeArguments[0];
        var sourceType = argument.ToDisplayString()
            ?? throw new System.Exception("sourceType is null");
        var isValueType = !sourceType.EndsWith("?") && argument.IsValueType;
        return (sourceType, isValueType);
    }
    #endregion
}
